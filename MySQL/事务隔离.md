### 事务的四种隔离等级

![image-20220317184907828](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220317184907828.png)

#### 三种并发访问产生的问题：

1. 脏读

   A事务读取B事务未提交的数据，如果B事务因为发生了错误而回滚，则事务读取的数据就是脏数据。

   <img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220317191428994.png" alt="image-20220317191428994" style="zoom:50%;" />

2. 不可重复读

   事务A在事务执行期间会执行多次相同的查询语句，而B事务在A事务的两次查询中对A事务需要查询的字段的值进行修改，导致事务前后执行的查询结果不一样，这就是不可重复读。

   <img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220317192119858.png" alt="image-20220317192119858" style="zoom:50%;" />

3. 幻读

   事务A在执行读取操作，需要两次统计数据的总量，前一次查询总量后，此时事务B执行了新增语句的操作并提交后，这个时候事务A统计到的数据总量发生了变化，这就是幻读。

   <img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220317192526404.png" alt="image-20220317192526404" style="zoom:50%;" />

- 不可重复读和幻读有什么区别

  - 不可重读读是读取了其他事务修改的数据，**针对update操作**。

    解决：使用行级锁，锁定该行，只有当其他事务多次读取数据操作完成之后，才允许事务B修改数据。

  - 幻读是读取了其他事务新增的数据，**针对insert和delete**。

    解决：使用表级锁，锁定该表，事务A多次读取数据完成之后才释放该锁，事务B才能插入数据。



#### 事务的隔离级别

1. 读未提交

   一个事务还没有提交，另外一个事务就能够看到它的修改

2. 读提交

   一个事务提交之后，另外一个事务才能够看到它的修改

3. 重复读

   事务执行前后的数据保持一致性

4. 串行化

   顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。



- 下面举例说明四个事务的隔离级别

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220317193826107.png" alt="image-20220317193826107" style="zoom:50%;" />

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。
- 若隔离级别是“串行化”，则在事务 B执行插入语句，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。



### 事务隔离等级的实现

#### 读未提交

该隔离等级，事务并没有添加锁

#### 读提交

在RC级别中，数据的读取都是不加锁的，但是数据的加入、修改和删除都是需要加锁的。

#### 可重复读

快照读

#### 串行化