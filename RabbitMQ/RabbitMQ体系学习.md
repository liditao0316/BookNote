## 概述

>RabbitMQ是唯一一个实现了AMQP标准的消息服务器；可靠性，RabbitMQ的持久化支持，保证了消息的稳定性；
>
>高并发，RabbitMQ使用了Erlang开发语言，Erlang是为电话交换机开发的语言，天生自带高并发光环，和高可用特性；
>
>集群部署简单，正是应为Erlang使得RabbitMQ集群部署变的超级简单；

## 应用场景

### 业务场景概念

> **异步处理**：将业务中属于非核心或不重要的流程部分，使用消息异步通知的方式发给目标系统，这样主业务流程无需同步等待其他系统的处理结果，从而达到系统快速响应的目的。
>
> **应用解耦**：系统间通过消息通信，不需要关系其他系统
>
> **流量削峰**：可以通过消息队列长度控制请求量；可以缓解短时间内的并发请求
>
> **日志处理**：解决大量的日志传输
>
> **消息通讯**：消息队列一般内置了高效的通讯机制，因此也可以用在纯的消息通讯。比如聊天室等

### 实际业务场景

#### 异步处理

如网站的用户注册场景，在用户注册成功后，还需要发送注册邮件与注册短信，这两个流程使用RabbitMQ消息服务通知邮件发送系统与短信发送系统，从而提升注册流程的响应速度。

![RabbitMQ的应用场景1](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF1.jpg)

​																		图1串行发送注册邮件与短信流程

![RabbitMQ的应用场景2](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF2.jpg)

​																图2借助消息队列异步发送注册邮件与短信流程

#### 流量削峰

在电子商务系统或大型网站中，**上下游系统处理能力存在差异**，处理能力高的上游系统的突发流量可能会对处理能力低的某些下游系统造成冲击，那么就可以使用**中间件技术**提高下游系统的可用性同时降低系统实现的复杂性。电商大促销等流量洪流突然来袭时，可以通过**消息队列堆积缓存订单**等信息，在下游系统有能力处理消息的时候再处理，避免下游订阅系统因突发流量崩溃。消息队列提供亿级消息堆积能力，3天的默认保留时长，消息消费系统可以错峰进行消息处理。

另外，在商品秒杀、抢购等流量短时间内暴增场景中，为了防止后端应用被压垮，可在前后端系统间使用RabbitMQ消息队列传递请求。

![RabbitMQ的应用场景3](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF3.jpg)

​																					图3消息队列应对秒杀大流量场景

#### 系统解耦

以电商秒杀、抢购等流量短时间内暴增场景为例，传统做法是，用户下单后，订单系统发送查询请求到库存系统，等待库存系统返回请求结果给订单系统。如果库存系统发生故障，订单系统获取不到数据，订单失败。这种情况下，订单系统和库存系统两个子系统高耦合。

![RabbitMQ的应用场景4](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF4.jpg)

​																							图4系统高耦合



引入RabbitMQ消息队列，当用户下单后，将消息写入到RabbitMQ消息队列中，然后返回用户下单成功。

库存系统订阅下单的消息，消费下单消息，然后进行库操作。即使库存系统出现故障，也不影响用户下单。

![RabbitMQ的应用场景5](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/RabbitMQ%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF5.jpg)

​																								图5系统解耦

#### 高可用

镜像队列是开源RabbitMQ2.6.0版本新增的一个功能，

## 底层原理

### 框架设计

![](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/SouthEast.jpeg)

**Broker**：它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,
**Exchange**：消息交换机,它指定消息按什么规则,路由到哪个队列。
**Queue**：消息的载体,每个消息都会被投到一个或多个队列。
**Binding**：绑定，它的作用就是把exchange和queue按照路由规则绑定起来.
**Routing Key**：路由关键字,exchange根据这个关键字进行消息投递。
**vhost**：虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。
**Producer**：消息生产者,就是投递消息的程序.
**Consumer**：消息消费者,就是接受消息的程序.
**Channel**：消息通道,在客户端的每个连接里,可建立多个channel。



## 功能模块的设计与实现

### AMQP协议

> AMQP协议是一个二进制协议，具有一些现代特性：多信道、异步、跨平台、协商式、安全、中立、高效

**AMQP被划分为三层**：

- **模型层**：定义了一套命令，客户端应用可以通过这些命令来实现业务功能
- **会话层**：负责将命令通过客户端传递给服务器，再将服务器的应答传送给客户端应用。会话层为这个消息传递过程提供可靠性、同步机制和错误处理。
- **传输层**：传输二进制流，同时提供帧处理、信道复用、错误检测和数据表示。



#### AMQP基本组成部分

##### Connection连接

使用认证机制的TCP连接

##### Channel通道

同一应用内一次TCP连接共享成为多个轻量级的线程通道，用通道号标识。详细可参考 JAVA 的NIO实现。

##### VHost虚拟主机

同一MQ代理实现隔离的环境，类似于操作系统上层的虚拟机。

##### Exchange交换机

AMQP协议提供了四种交换机的实现方式，上面提到的AMQP default就是一种直连交换机，每个队列默认绑定该交换机且路由为其队列名

##### Queue队列

队列一般由客户端在消费者消费前创建。一般再次声明队列时如果队列的属性不一致，会有异常抛出。队列需要绑定（订阅）关注的交换机来接收消息。

##### Consumer和producer

AMQP 0-9-1模型中提供了两种消费方式

- **push** API 消费者等待消息到来消费消息（wait）
- **pull** API 消费者主动去消息中间件获取消息（get）



#### AMQP消息机制

- 消息确认（生产者：直接投递和成功后确认；消费者：自动确认和显示确认）
- 拒绝消息（丢弃或重新入队）
- 预取消息
- 消息持久化（暂存/持久化）
- 消息主体（属性和有效荷载）



### 消息路由模式

#### fanout模式

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220327140852448.png" alt="image-20220327140852448" style="zoom:50%;" />

与fanout模式的路由绑定的队列都能够收到来自该路由的消息。

#### Direct模式

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220327141216412.png" alt="image-20220327141216412" style="zoom:50%;" />

Direct模式是fanout模式的叠加，增加了routingKey，目的是通过消息的routingKey区分不同的消息。

#### Topic模式

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220327141352891.png" alt="image-20220327141352891" style="zoom:50%;" />

Topic模式是Direct模式的叠加，增加了模糊路由routingKey的模式

### 消息队列

#### 死信队列

DLX，全称Dead- Letter-exchange，死信交换机。当消息在队列中变成死信之后，他能被发送到另外一个交换机中，这个交换机就是DLX。而与DLX绑定的队列就是死信队列。

**导致死信的几种原因**：

- 消息被拒
- 消息过期
- 队列满了，无法再添加

#### 优先级队列

RabbitMQ在3.5.0版本的时候实现了优先级队列。任何一个队列都可以通过客户端配置参数方式设置一个优先级(但是不能使用策略的方式配置这个参数)。当前优先级的最大值为：255。这个值最好在1到10之间。

通过声明队列方式并使用参数`x-max-priority`指定当前的队列为优先级队列。这个优先级队列支持的参数必须是一个整数在1到255.

```java
Channel ch = ...;
Map<String, Object> args = new HashMap<String, Object>();
args.put("x-max-priority", 10);
ch.queueDeclare("my-priority-queue", true, false, false, args);
```

**与消费者的交互**
了解生产者者使用优先级队列时的工作方式非常重要。默认情况下，消费者在确认任何消息之前可能会收到大量消息，但仅受网络背压限制。

因此，如果这种**饥饿的生产者**连接到一个空队列，然后将消息发布到该队列中，则消息可能不会花费任何时间在队列中等待。在这种情况下，优先级队列将没有机会优先处理它们，也就是无法对信息进行一个优先级排序。在大多数情况下，您需要在使用者的手动确认模式下使用 basic.qos 方法，以限制随时可以发送的消息数，从而允许对邮件进行优先级排序。

#### 延迟机制

#### 消息的分发策略

#### 事务机制

### RabbitMQ的缺点



