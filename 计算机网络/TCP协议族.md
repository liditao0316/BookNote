## 一、传输层中的TCP和UDP协议

### 1. TCP三次握手

#### 1.1. TCP报文首部

- `源端口和目的端口`，各占2个字节，分别写入源端口和目的端口；
- `序列号`，占4个字节，**TCP连接中传送的字节流中的每个字节都按顺序编号**。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
- `确认号`，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
- `数据偏移`，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
  保留，占6位，保留今后使用，但目前应都位0；
- `紧急URG`，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
- `确认ACK`，**仅当ACK=1时，确认号字段才有效**。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
- `推送PSH`，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
- `复位RST`，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
- `同步SYN`，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
- `终止FIN`，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
- `窗口`，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
- `检验和`，占2字节，校验首部和数据这两部分；
- `紧急指针`，占2字节，指出本报文段中的紧急数据的字节数；
- `选项`，长度可变，定义一些其他的可选的参数。

#### 1.2. TCP三次握手流程

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220309150916697.png" alt="image-20220309150916697" style="zoom:50%;" />

- 重点理解：seq表示序号，ack表示确认号

- TCP服务器进程先创建传输控制块TCB，此时服务器进入LISTEN状态
- 第一次握手：客户端先服务端发送一个请求报文，其SYN=1，初始序列号seq=x，此时客户端进入SYN-SENT（**同步已发送状态**）
- 第二次握手：服务端向客户端发送一个响应报文，其ACK=1，SYN=1，服务器端的初始序列号seq=y，确认号ack=x+1，表示希望下一次收到来自客户端的序列号是从x+1开始的。此时，TCP服务器进程进入了SYN-RCVD（**同步收到状态**）
- 第三次握手：客户端向服务端发送确认报文，其ACK=1，当前报文序列号seq=x+1，ack=y+1，当前，TCP连接已建立，客户端进入ESTABLISHED（已建立连接）状态。

#### 1.3. 为什么TCP要三次握手

避免重复连接，导致资源浪费以及数据传输异常。假如客户端发送了一个连接请求，但是由于网络拥塞等等原因，客户端无法收到来自服务器的响应，然后重发了一个连接请求，现在网络恢复正常，客户端和服务器通过两次握手，完成了连接；此时第一个包，由于网络的恢复，服务器成功接收到了该请求并回复请求，这时客户端收到响应，最后客户端和服务端有两次连接。同时三次以上的握手会浪费连接的效率，增加系统的开销，因此没必要。



### 2. TCP四次挥手

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220309154626080.png" alt="image-20220309154626080" style="zoom:50%;" />

- 关键：FIN状态字

- 第一次挥手：客户端进程发送连接释放报文，其FIN状态字为1，客户端进入终止等待1的状态，注意此时客户端还能收到报文。
- 第二次挥手：服务器进程发送收到连接释放报文，确认号ack=u+1,表示知道客户端要关闭连接了，但是还需要把为发送的数据发送完毕
- 第三次挥手：服务器端进程将剩下的所有报文发送给客户端，然后发送一个连接释放报文，该报文FIN状态字为1，确认号为ack=u+1，表示所有报文已全部发送，可以关闭连接了。
- 第四次挥手：客户端收到连接释放报文，然后发送一个确认报文，表示客户端已经关闭连接。

#### 2.1. 为什么客户端最后还要等待2MSL？

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

#### 2.2. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。



### 3. TCP和UDP的区别

- TCP协议的特点：
  - TCP是面向连接的运输层协议
  - 每一条连接只能有两个端点，每一条TCP连接只能是点对点的
  - TCP提供可靠交付的服务
  - TCP提供全双工通信
  - 面向字节流
- UDP协议：
  - UDP是无连接的
  - UDP使用尽最大努力交付，即不保证可靠交付
  - UDP是面向报文的
  - UDP没有拥塞控制
  - UDP支持一对一，一对多，多对多的交互通信



### 4. TCP的拥塞控制

> TCP进行拥塞控制的算法有四种：
>
> - 慢开始
> - 拥塞避免
> - 快重传
> - 快恢复

理解两个概念：

- 拥塞窗口cwnd
- 发送窗口
- 最大报文段SMSS
- 慢开始门限ssthresh

#### 慢开始和拥塞避免

`发送方控制拥塞窗口`的原则是：只要网络没有出现拥塞，拥塞窗口就可以再增加一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。

`慢开始算法`的思路是由小到大逐渐增大发送窗口，也就是说，有小到大逐渐增大拥塞窗口数值。每经过一个传输轮次，拥塞窗口cwnd就加倍。

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220324182917399.png" alt="image-20220324182917399" style="zoom:50%;"/>

为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始`门限ssthresh`，慢开始门限ssthresh的用法如下：

- 当cwnd<ssthresh时，使用上述的慢开始算法。
- 当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法
- 当cwnd=ssthresh时，既可以使用慢开始算法，也可使用拥塞避免算法

![image-20220324183134081](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220324183134081.png)

`拥塞避免算法`的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。

`快重传算法`可以让发送方**尽早知道发生了个别报文段的丢失**。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要**立刻发送确认**，即使收到了**失序的报文段**也要发出对已收到的报文段的重复确认。`快重传算法`规定，发送方只要**一连收到3个重复确认**，就知道接收方确认没有收到报文段，因此**立即进行重传**

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220324183025685.png" alt="image-20220324183025685" style="zoom:50%;" />

`快恢复算法`：发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh = cwnd/2，同时设置拥塞窗口cwnd = ssthresh，并开始执行拥塞避免算法。



### 5. TCP报文段的首部格式

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220325145653329.png" alt="image-20220325145653329" style="zoom:50%;" />



### 6. 滑动窗口

![image-20220420094947988](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220420094947988.png)

> 发送窗口 = 接收窗口 = p3 - p1
>
> 已发送但未收到确认窗口 = p2 - p1
>
> 可用窗口= p3 - p2

#### 窗口和缓存的关系

由于TCP是全双工通信的，一方既有发送缓存区，也有接收缓存区。要注意区分

注意：

- 缓存空间和序号空间都是有限的，并且都是循环使用的

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220420095848526.png" alt="image-20220420095848526" style="zoom:50%;" />

#### 固定大小的窗口滑动

#### 动态变化的窗口滑动

原因：当我们的应用程序无法及时读取数据时，那么窗口的可用空间将会减少。

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220420102844936.png" alt="image-20220420102844936" style="zoom:50%;" />



### 7. TCP的流量控制

>所谓流量控制就是**让发送方的发送速率**不要太快，要让接收方来得及接收。
>
>利用滑动窗口机制可以很方便地在TCP连接上实现**对发送方的流量控制**

#### TCP的传输效率

可以用不同的机制来控制TCP报文段的发送时机。例如，第一种机制是TCP维持一个变量，它等于**最大报文段长度MSS**。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。

### 8. TCP粘包和拆包

#### 什么是TCP粘包、拆包

由于TCP传输协议是面向字节流的，没有消息保护边界。

- 一方发送多个报文可能会被合并成一个大的报文进行传输，这就是粘包。
- 同时也有可能将一个大的报文拆分成多个小的报文进行传输，这就是拆包。

![img](https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/1620.jpeg)



#### 产生这两种现象的原因

- TCP传输协议是面向字节流的，没有消息保护边界
- socket缓冲区
- 滑动窗口
- MTU/MSS的限制

​		MTU是最大传输单元，是数据链路层对一次可以发送的最大数据的限制。MSS(Maxitum Segment Size,最大分段大小)是TCP报文中data部分的最大长度，是传输层对一次可以发送的最大数据的限制。

<img src="https://ldt-typora.oss-cn-shenzhen.aliyuncs.com/img/image-20220420110054225.png" alt="image-20220420110054225" style="zoom:50%;" />



#### 常见的解决方案

1. 发送端将每个报文都封装成固定长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度。（**在报文发送到socket缓冲区之前完成**）
2. 发送端在每个包末尾使用固定的分隔符，例如\r\n。如果发生拆包则需要等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议
3. 将消息分为消息体和消息头部，头部中保存消息体的长度，只有读取足够长度的数据之后才算完整读到一个消息。



#### Netty对粘包和拆包问题的处理

Netty对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如：

- LineBasedFrameDecoder：以行为单位进行数据包的解码；
- DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；
- FixedLengthFrameDecoder：以固定长度进行数据包的解码；
- LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）；